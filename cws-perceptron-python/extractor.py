#coding=utf-8

import unicodedata
from symbols import BOT , EOT , BOS , EOS , LEXICON_MATCH_MAX_LENGTH  
from tools import Tools
from wsatom_char import WSAtomTranslator
class Extractor(object) :
    
    def __init__(self,lexicon) :
        self.lexicon = lexicon

    def extract_emit_features(self,instance) :
        '''
        extract emit feature(features of current sequence) from instance 
        
        Args :
            instance : list , every element is a WSAtom(unigram)
        Returns :
            emit_features : list of list , 
                            most basic element is feature , is str generated by template rule ,
                            inner list is the feature list , which length is decided by the feature template . 
                            outer list is the feature list for every unigram of the instance
                            => [ [ "1=我","2=是",..] ... ] 
        '''
        instance_len = len(instance)
        emit_features_list = []
        match_state = self.build_lexicon_match_state(instance)
        for pos in range(instance_len) :
            #! unigram word feature
            W_cur = str(instance[pos])
            W_pre2 = str(instance[pos-2]) if pos - 2 >= 0 else BOS
            W_pre1 = str(instance[pos-1]) if pos - 1 >= 0 else BOS 
            W_nxt1 = str(instance[pos+1]) if pos + 1 < instance_len else EOS 
            W_nxt2 = str(instance[pos+2]) if pos + 2 < instance_len else EOS 
            #! type feature
            T_cur = instance[pos].get_type_str()
            T_pre1 = instance[pos-1].get_type_str() if pos - 1 >= 0 else BOT
            T_nxt1 = instance[pos+1].get_type_str() if pos + 1 < instance_len else EOT
            #! lexicon feature
            L_head = str(match_state[pos][0])
            L_middle = str(match_state[pos][1])
            L_end = str(match_state[pos][2])
            
            ## end , pack it
            f_list = [W_cur , W_pre2 , W_pre1 , W_nxt1 , W_nxt2 , T_cur , T_pre1 , T_nxt1 , L_head , L_middle , L_end ] # all are encoding str
            cur_emit_feature = [ "=".join([ str(f_idx) , f_list[f_idx]]) for f_idx in range(len(f_list)) ]
            emit_features_list.append(cur_emit_feature)
        return emit_features_list

    def build_lexicon_match_state(self , instance) :
        '''
        for every unigram , record :
        as a word head , the word 's max length
        as a word middle , the word's max length
        as a word end , the word's max length
        '''
        instance_len = len(instance)
        match_state = [ [ 1 ] * 3 for i in range(instance_len) ] #! minimum length is 1
        for i in range(instance_len) :
            j = min( i + LEXICON_MATCH_MAX_LENGTH , instance_len - 1 )
            while j > i :
                test_word = WSAtomTranslator.trans_atom_gram_list2unicode_line(instance[i:j+1])
                if test_word in self.lexicon :
                    word_len = j - i + 1
                    #! max length as the word head 
                    match_state[i][0] = max( match_state[i][0] , word_len )
                    #! max length as the word middle
                    for interval in range(i+1 , j) :
                        match_state[interval][1] = max( match_state[interval][1] , word_len )
                    #! max length as the word end
                    match_state[j][2] = max( match_state[j][2] , word_len )
                    break
                j -= 1

        return match_state

